## 1. 总体设计

### 1.1 概述

此项目为 2023 年春季北京邮电大学操作系统课程设计项目，题目为《操作系统模拟程序的设计与实现》，课程设计的目的在于：加深理解操作系统的基本功能、原理和工作机制，理解并掌握操作系统的实现方法和技术，培养学生理解问题、分析问题、解决问题的能力，培养学生团队合作精神、组织协调能力，进一步培养提高学生的编程实践能力。

#### 1.1.1 功能描述

此项目设计并实现一个具有操作系统基本功能的软件，要求该软件具有操作系统的如下基本功能：

- 进程管理功能，如进程创建(new)、进程调度(scheduling)、进程阻塞(block)、进程唤醒(wakeup)、进程同步(synchronize)等。
- 内存管理功能，进程存储空间的分配和回收等。
- 文件系统，目录/文件的创建和删除、空间分配和回收。
- 设备管理，设备的申请、分配、使用、释放等。
- 程序运行的交互 UI 界面。
- 程序需要模拟实现操作系统的中断机制。

#### 1.1.2 运行环境

程序的运行环境为  *Windows Subsystem for Linux* (*WSL*) ，即 Windows 系统环境下安装的 Linux 虚拟机，所使用的 Linux 发型版为 [Debian 11 (bullseye)](https://www.debian.org/News/2021/20210814), 程序运行的宿主机内核版本为 Linux 5.10.16.3-microsoft-standard-WSL2  x86_64 GNU/Linux。

#### 1.1.3 开发环境

项目使用 VScode 代码编辑器配合 C/C++ 语言相关插件进行开发，团队使用 [Git](https://git-scm.com) 作为代码版本管理工具，代码托管在 [Github](https://github.com) 上的私有远程仓库进行协同开发，所有的代码遵循标准 GNU/Linux 系统 API, 编程语言上使用 C++17 标准进行开发。

### 1.2 设计思想

总体来说，程序使用面向对象的软件工程设计思想进行开发，我们将程序模块化设计，划分为如下几个模块：

1. 系统内存管理模块
2. 系统进程管理模块
3. 系统中断机制模块
4. 文件系统模块
5. 程序交互 UI 界面模块
6. 系统时钟管理 (timer) 模块
7. 系统设备管理模块

#### 1.2.1 软件设计构思

将程序设计划分为上述的几个模块，各个模块之间互相依赖写协作，共同实现操作系统的各个功能。举例来讲，操作系统的内存管理和进程管理为最基础以及最重要的模块，所有的其他模块和功能都要依赖内存管理，以及进程管理功能。与此同时系统的中断机制伴随程序的始终，现代操作系统使用中断驱动，我们将时钟管理模块(timer) 与此结合一起实现。

在交互 UI 界面上，程序在终端模拟一个操作系统 Shell，以及我们自己实现基本的交互指令。举例来说比如 Linux 默认的 `ls` shell 指令作用为列出当前目录下的文件功能。通过这种 Shell 指令与操作系统全程交互，实现用户对操作系统的使用和控制。

对于文件系统模块，设计模拟实现基本的操作系统文件增删读写功能，由于是“模拟”操作系统的功能，所以我们直接使用 Linux 系统提供给用户的底层 API，使用 C/C++ 语言自己更高级的语言特性来调用实现。

现代操作系统同时需要具有设备管理功能，在 Linux 系统下，一切设备都对应一个文件描述符，程序运行开始时刻监听设备的数量，插入已经拔出系统的各种设备等。

#### 1.2.2 关键技术与算法

需要考虑使用何种算法来实现的模块有内存管理模块、进程管理模块、文件系统模块。对于内存管理而言，现代操作系统常见的内存管理算法有三种：连续分区、页式和按需调页。在实现难度上，后两种都要考虑与虚拟内存的交互，但是在我们的“模拟”程序中，实现虚拟内存是内存较大的，所以目前暂定使用连续分页的机制来实现。在后续的团队协作开发进度来看，如果有更充裕的时间我们将考虑更换内存管理算法，比如使用最复杂的按需调页机制。

进程管理部分也有需要选择实现的算法，现代操作系统常见的进程调度算法比如先来先服务FCFS，时间片轮转算法(Round Robin) 算法，多级队列调度算法等。我们暂定使用时间片轮转算法来进程系统进程调度。

文件系统实现部分，使用树形结构等数据结构来维护实现，比如维护文件描述符，我们可以考虑使用哈希表来存储等操作。

#### 1.2.3 基本数据结构

在各种模块算法实现过程中，必然需要借助相对应的数据结构来辅助完成。在进程管理中，我们需要维护一个进程的队列，以时间片轮转算法来说，当一个进程的时间片用完后就回到队尾，队头的进程出队列进行运行，如下图所示 (图源 Wikipedia)：

![image.png](概要设计.assets/WkKHS8tnUBmQNrs.png)

在文件系统或者磁盘管理部分，数据结构也是重度依赖使用的。文件系统主要依赖 FCB 的功能实现，使用多叉树来维护文件结构。磁盘管理功能来说，常见的位示图(bitmap) ，或者使用链表来维护空闲以及被占用的磁盘块，如下图所示为使用 16 bit 序列 `0000111000000110` bitmap 维护的空闲磁盘空间：

<img src="概要设计.assets/1-265.png" alt="image" style="zoom:50%;" />

### 1.3 基本处理流程

对于模拟一个现代的 Linux 操作系统，我们忽略掉硬件启动的部分，对于软件层面包括的处理流程主要为：

1. 内核启动：内核在启动时，首先会进行初始化，包括初始化内存管理、进程管理、文件系统等模块。然后，内核会启动系统的第一个进程 —— systemd，systemd 会负责启动其它服务和进程。对于我们自己模拟的程序，需要自己实现一个初始化程序来初始化所有系统服务。

2. 服务启动：系统初始化进程会启动各种服务，例如网络服务、文件系统服务、用户服务、日志服务等。
3. 进程管理： 系统使用进程来管理程序和服务，内核负责管理进程，包括创建、撤销、调度、通信和同步等操作。
4. 文件管理：操作系统通过文件系统管理文件和目录，支持各种文件系统类型和访问权限设置，包括文件的创建、读取、写入、删除、复制等操作。
5. 设备管理：操作系统会实时监听所有系统识别到的设备，同时映射为系统中的文件描述符。

我们的模拟程序会同时维护上述 5 个流程，以模拟实现现代操作系统的基本功能。



## 2. 软件的体系结构和模块设计

### 2.1 软件的体系结构

#### 2.1.1 软件体系结构框图

#### 2.1.2 软件主要模块及其依赖关系说明

### 2.2 软件数据结构设计

#### 2.2.1 全局数据结构说明

#### 2.2.2 数据结构与系统单元的关系

### 2.3 软件接口设计

#### 2.3.1 外部接口

#### 2.3.2 内部接口





## 3. 用户界面设计

### 3.1 界面的关系图

### 3.2 界面说明

#### 3.2.1 界面1

#### 3.2.2 界面2

#### 3.2.3 界面3



##  4. 相关处理流程

### 4.1 进程管理设计说明

#### 4.1.1 进程管理数据结构说明

进程控制块 (Process Control Block, PCB) 是操作系统中描述进程或任务状态信息的数据结构，它存储了进程的各种信息，包括进程标识符、进程状态、进程优先级、程序计数器、寄存器状态、内存分配状态等。

#### 4.1.2 进程管理算法及流程说明

1. 进程管理算法主要包括进程调度算法和进程同步与通信算法。其中，进程调度算法用于决定哪些进程应该被执行，如何分配 CPU 时间片；进程同步与通信算法用于协调多个进程之间的资源竞争和进程间的通信。

   进程管理流程如下：

   1. 进程创建：操作系统根据用户请求或自身需要创建进程。
   2. 进程调度：根据进程调度算法，决定哪些进程应该被执行，如何分配 CPU 时间片。
   3. 进程执行：执行进程的代码段。
   4. 进程同步与通信：协调多个进程之间的资源竞争和进程间的通信。
   5. 进程退出：进程执行完毕或因某种原因被强制退出。

#### 4.1.3 数据存储说明

进程控制块 PCB 存储在操作系统的内核空间中，具体实现可以采用链表或数组等数据结构。

### 4.2 内存管理设计说明

#### 4.2.1 内存管理数据结构说明

在内存管理中，我们需要定义以下数据结构：

- 内存块（Memory Block）：表示内存中的一块空间，包括其起始地址和大小信息。

#### 4.2.2 内存管理算法及流程说明

内存管理的算法和流程如下：

- 内存分配：当进程需要分配内存时，操作系统会遍历内存块列表，找到第一个空闲的内存块并将其分配给进程。如果没有足够的连续内存块可供分配，则会进行内存压缩或者进行虚拟内存管理。
- 内存回收：当进程释放内存时，操作系统将该内存块标记为空闲状态，并将其合并到相邻的空闲内存块中，以便后续进程使用。

#### 4.2.3 数据存储说明

在内存管理中，需要对内存块的信息进行存储，常用的存储方式有：

- 内存块链表：将内存块组织成链表形式，每个节点存储一个内存块的信息，包括其起始地址和大小信息以及状态（已分配或空闲）等。

### 4.3 中断处理设计说明

#### 4.3.1 中断处理数据结构说明

在中断处理中，我们需要定义以下数据结构：

- 中断向量表（Interrupt Vector Table，IVT）：用于存储不同中断类型的处理程序的入口地址。

#### 4.3.2 中断处理算法及流程说明

中断处理的算法和流程如下：

- 中断触发：当系统发生中断事件时，会将中断类型和相关数据保存到硬件中断栈中，并跳转到相应的中断处理程序。
- 中断处理：中断处理程序会从硬件中断栈中获取中断类型和相关数据，并根据中断类型调用相应的处理函数进行处理。
- 中断返回：处理完成后，中断处理程序会将相关数据从硬件中断栈中恢复，然后使用中断返回指令返回到中断触发点继续执行。

#### 4.3.3 数据存储说明

在中断处理过程中，需要保存中断类型和相关数据，这些数据需要存储在硬件中断栈中。同时，中断向量表也需要被存储在内存中。

### 4.4 文件系统设计说明

#### 4.4.1 文件系统数据结构说明

在文件系统中，我们需要定义以下数据结构：

- 文件控制块（File Control Block，FCB）：用于描述文件的相关信息，如文件名、文件大小、文件权限等。
- 目录项（Directory Entry）：用于描述文件和目录的关系和位置，如文件名、文件所在的目录等。
- 文件系统结构（File System Structure）：用于描述整个文件系统的结构，如根目录的位置、磁盘块的分配方式等。

#### 4.4.2 文件系统算法及流程说明

文件系统的算法和流程如下：

- 文件读写：当应用程序需要读写文件时，先通过文件名查找到对应的文件控制块，然后根据文件控制块中记录的磁盘块号读取或写入文件数据。
- 目录操作：当应用程序需要创建、删除或重命名文件或目录时，需要通过目录项进行操作，如创建新的目录项、删除现有目录项等。
- 磁盘块管理：文件系统需要对磁盘块进行管理，如分配磁盘块、释放磁盘块等。

#### 4.4.3 数据存储说明

在文件系统中，需要将文件数据和文件系统结构保存在磁盘上。文件数据需要被存储在磁盘块中，而文件系统结构需要被存储在固定的磁盘位置上，如第一个磁盘块。同时，文件控制块和目录项也需要被存储在磁盘上，一般会和文件数据存储在相邻的磁盘块中。

### 4.5 设备处理

#### 4.5.1 设备处理数据结构说明

在设备处理中，我们需要定义以下数据结构：

- 设备控制块（Device Control Block，DCB）：用于描述设备的相关信息，如设备的名称、类型、状态等。
- I/O 请求块（I/O Request Block，IRB）：用于描述设备的 I/O 请求，如读取或写入数据的起始位置和大小等。

#### 4.5.2 设备处理算法及流程说明

设备处理的算法和流程如下：

- 设备驱动程序：负责与硬件设备进行通信，处理设备相关的中断和异常，向 I/O 请求队列中添加或移除 I/O 请求。
- I/O 请求队列管理：管理 I/O 请求队列，处理 I/O 请求的优先级、顺序、并发等问题。
- 设备控制块管理：管理设备控制块，维护设备状态信息，如设备是否空闲、是否可用等。

#### 4.5.3 数据存储说明

在设备处理中，一般不需要进行数据存储。设备控制块和 I/O 请求块的数据可以直接保存在内存中，而不需要保存在磁盘上。



## 5. 总结



## 参考文献：
